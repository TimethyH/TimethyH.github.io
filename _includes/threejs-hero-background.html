<!-- Three.js Hero Background -->
<div id="threejs-hero-container"></div>

<style>
  #threejs-hero-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
    overflow: hidden;
  }
  
  #threejs-hero-container canvas {
    display: block;
  }
  
  .jumbotron {
    position: relative;
    overflow: hidden;
    background-image: none !important;
  }
  
  .jumbotron > * {
    position: relative;
    z-index: 10;
  }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
(function() {
  let scene, camera, renderer;
  let cubes = [];
  let lightRays = [];
  let mouseX = 0, mouseY = 0;
  
  function init() {
    const container = document.getElementById('threejs-hero-container');
    if (!container) return;
    
    scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x000510, 1, 100);
    
    camera = new THREE.PerspectiveCamera(75, container.offsetWidth / container.offsetHeight, 0.1, 1000);
    camera.position.set(0, 5, 15);
    camera.lookAt(0, 0, 0);
    
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.offsetWidth, container.offsetHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x1c1c1e);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    container.appendChild(renderer.domElement);
    
    const groundGeo = new THREE.PlaneGeometry(100, 100);
    const groundMat = new THREE.MeshStandardMaterial({ 
      color: 0x1c1c1e,
      roughness: 0.8,
      metalness: 0.2
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -5;
    ground.receiveShadow = true;
    scene.add(ground);
    
    const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
    sunLight.position.set(0, 25, 30);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 2048;
    sunLight.shadow.mapSize.height = 2048;
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far = 100;
    sunLight.shadow.camera.left = -30;
    sunLight.shadow.camera.right = 30;
    sunLight.shadow.camera.top = 30;
    sunLight.shadow.camera.bottom = -30;
    scene.add(sunLight);
    
    const ambient = new THREE.AmbientLight(0x222244, 0.3);
    scene.add(ambient);
    
    const letterMaterial = new THREE.MeshStandardMaterial({
      color: 0xcc5500,
      emissive: 0xff4400,
      emissiveIntensity: 0.3,
      roughness: 0.5,
      metalness: 0.5
    });
    
    const tShape = new THREE.Shape();
    tShape.moveTo(-5, 4);
    tShape.lineTo(5, 4);
    tShape.lineTo(5, 2);
    tShape.lineTo(1, 2);
    tShape.lineTo(1, -4);
    tShape.lineTo(-1, -4);
    tShape.lineTo(-1, 2);
    tShape.lineTo(-5, 2);
    tShape.lineTo(-5, 4);
    
    const extrudeSettings = {
      depth: 2,
      bevelEnabled: true,
      bevelThickness: 0.2,
      bevelSize: 0.2,
      bevelSegments: 3
    };
    
    const tGeometry = new THREE.ExtrudeGeometry(tShape, extrudeSettings);
    const tMesh = new THREE.Mesh(tGeometry, letterMaterial.clone());
    tMesh.position.set(-13, 2, -1);
    tMesh.castShadow = true;
    tMesh.receiveShadow = true;
    scene.add(tMesh);
    cubes.push(tMesh);
    
    const hGroup = new THREE.Group();
    const hExtrudeSettings = {
      depth: 2,
      bevelEnabled: true,
      bevelThickness: 0.2,
      bevelSize: 0.2,
      bevelSegments: 3
    };
    
    const hLeftShape = new THREE.Shape();
    hLeftShape.moveTo(-5, 4);
    hLeftShape.lineTo(-3, 4);
    hLeftShape.lineTo(-3, -4);
    hLeftShape.lineTo(-5, -4);
    hLeftShape.lineTo(-5, 4);
    const hLeftGeo = new THREE.ExtrudeGeometry(hLeftShape, hExtrudeSettings);
    const hLeftMesh = new THREE.Mesh(hLeftGeo, letterMaterial.clone());
    hGroup.add(hLeftMesh);
    
    const hMiddleShape = new THREE.Shape();
    hMiddleShape.moveTo(-3, 1);
    hMiddleShape.lineTo(3, 1);
    hMiddleShape.lineTo(3, -1);
    hMiddleShape.lineTo(-3, -1);
    hMiddleShape.lineTo(-3, 1);
    const hMiddleGeo = new THREE.ExtrudeGeometry(hMiddleShape, hExtrudeSettings);
    const hMiddleMesh = new THREE.Mesh(hMiddleGeo, letterMaterial.clone());
    hGroup.add(hMiddleMesh);
    
    const hRightShape = new THREE.Shape();
    hRightShape.moveTo(3, 4);
    hRightShape.lineTo(5, 4);
    hRightShape.lineTo(5, -4);
    hRightShape.lineTo(3, -4);
    hRightShape.lineTo(3, 4);
    const hRightGeo = new THREE.ExtrudeGeometry(hRightShape, hExtrudeSettings);
    const hRightMesh = new THREE.Mesh(hRightGeo, letterMaterial.clone());
    hGroup.add(hRightMesh);
    
    hGroup.position.set(13, 2, -1);
    hGroup.castShadow = true;
    hGroup.children.forEach(function(mesh) {
      mesh.castShadow = true;
      mesh.receiveShadow = true;
    });
    scene.add(hGroup);
    cubes.push(hGroup);
    
    createVolumetricRays();
    
    window.addEventListener('resize', onWindowResize);
    document.addEventListener('mousemove', onMouseMove);
    
    animate();
  }
  
  function createVolumetricRays() {
    const dustGeo = new THREE.BufferGeometry();
    const dustCount = 2000;
    const dustPositions = new Float32Array(dustCount * 3);
    const dustColors = new Float32Array(dustCount * 3);
    const dustSizes = new Float32Array(dustCount);
    
    for (let i = 0; i < dustCount; i++) {
      const i3 = i * 3;
      dustPositions[i3] = (Math.random() - 0.5) * 80;
      dustPositions[i3 + 1] = Math.random() * 40 - 5;
      dustPositions[i3 + 2] = (Math.random() - 0.5) * 80;
      
      dustColors[i3] = 0.7;
      dustColors[i3 + 1] = 0.7;
      dustColors[i3 + 2] = 0.8;
      
      dustSizes[i] = Math.random() + 0.3;
    }
    
    dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
    dustGeo.setAttribute('color', new THREE.BufferAttribute(dustColors, 3));
    dustGeo.setAttribute('size', new THREE.BufferAttribute(dustSizes, 1));
    
    const dustMat = new THREE.PointsMaterial({
      size: 1,
      vertexColors: true,
      transparent: true,
      opacity: 0.2,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    
    const dust = new THREE.Points(dustGeo, dustMat);
    scene.add(dust);
    lightRays.push(dust);
  }
  
  function onMouseMove(event) {
    mouseX = (event.clientX / window.innerWidth) * 2 - 1;
    mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
  }
  
  function onWindowResize() {
    const container = document.getElementById('threejs-hero-container');
    if (!container) return;
    camera.aspect = container.offsetWidth / container.offsetHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.offsetWidth, container.offsetHeight);
  }
  
  function animate() {
    requestAnimationFrame(animate);
    
    const time = Date.now() * 0.0003;
    const targetX = mouseX * 15;
    const targetY = mouseY * 10 + 5;
    camera.position.x += (targetX - camera.position.x) * 0.05;
    camera.position.y += (targetY - camera.position.y) * 0.05;
    camera.lookAt(0, 0, 0);
    
    cubes.forEach(function(letter, i) {
      letter.position.y = 2 + Math.sin(time * 2 + i) * 0.3;
    });
    
    const dustSystem = lightRays[lightRays.length - 1];
    if (dustSystem) {
      const dustPositions = dustSystem.geometry.attributes.position.array;
      for (let i = 0; i < dustPositions.length; i += 3) {
        dustPositions[i] += Math.sin(time * 2 + i) * 0.01;
        dustPositions[i + 1] += 0.02;
        dustPositions[i + 2] += Math.cos(time * 2 + i) * 0.01;
        if (dustPositions[i + 1] > 40) {
          dustPositions[i + 1] = -5;
        }
      }
      dustSystem.geometry.attributes.position.needsUpdate = true;
    }
    
    renderer.render(scene, camera);
  }
  
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
</script>